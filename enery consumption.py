# -*- coding: utf-8 -*-
"""navyasrikarri.ipynb

Automatically generated by Colab.



### Project Description
This project involves the development of a web application for predicting energy consumption using time series forecasting models, specifically the Prophet model. The application allows users to select a state, specify a date range for historical data, and choose a forecast horizon. It then provides predictions of future energy consumption and visualizes the results.

### Inputs and Outputs
**Inputs:**
1. **State Selection:** A dropdown menu to select a specific state.
2. **Date Range:** Date pickers to specify the start and end dates for historical data.
3. **Forecast Horizon:** A slider to choose the number of months into the future for the prediction.

**Outputs:**
1. **Predictions Chart:** A line chart displaying historical energy consumption data and the predicted values.
2. **Mean Absolute Error (MAE):** A metric indicating the accuracy of the predictions.

### Expected Advancements in Society
This project aims to improve energy management and planning by providing accurate predictions of future energy consumption. It can help utility companies optimize energy distribution, reduce costs, and enhance grid reliability. Additionally, it can aid policymakers in making informed decisions regarding energy policies and sustainability initiatives.

### Model Choice
The Prophet model was chosen for this task due to its robustness in handling time series data with strong seasonal effects and its ability to incorporate holiday effects and missing data. Prophet is also user-friendly and provides interpretable results, making it suitable for stakeholders who may not be data science experts.

### Dataset Description
The dataset comprises energy consumption data across various Indian states, recorded on a daily basis. The columns include:

- **DateTime:** The date and time of the observation.
- **States:** Columns representing daily energy consumption values for each state (e.g., Punjab, Haryana, Rajasthan, Delhi, UP, etc.).

Example Data:

| DateTime   | Punjab | Haryana | Rajasthan | Delhi | UP   | Uttarakhand | HP   | J&K  | Chandigarh | ... | West Bengal | Sikkim | Arunachal Pradesh | Assam | Manipur | Meghalaya | Mizoram | Nagaland | Tripura | Date       |
|------------|--------|---------|-----------|-------|------|-------------|------|------|------------|-----|-------------|--------|-------------------|-------|---------|-----------|---------|----------|---------|------------|
| 2019-01-02 | 119.9  | 130.3   | 234.1     | 85.8  | 313.9| 40.7        | 30.0 | 52.5 | 5.0        | ... | 108.2       | 2.0    | 2.1               | 21.7  | 2.7     | 6.1       | 1.9     | 2.2      | 3.4     | 2019-01-02 |
| 2019-01-03 | 121.9  | 133.5   | 240.2     | 85.5  | 311.8| 39.3        | 30.1 | 54.1 | 4.9        | ... | 110.2       | 1.9    | 2.2               | 23.4  | 2.4     | 6.5       | 1.8     | 2.2      | 3.6     | 2019-01-03 |
| 2019-01-04 | 118.8  | 128.2   | 239.8     | 83.5  | 320.7| 38.1        | 30.1 | 53.2 | 4.8        | ... | 106.8       | 1.7    | 2.2               | 21.7  | 2.4     | 6.3       | 1.7     | 2.2      | 3.5     | 2019-01-04 |
| 2019-01-05 | 121.0  | 127.5   | 239.1     | 79.2  | 299.0| 39.2        | 30.2 | 51.5 | 4.3        | ... | 107.0       | 2.0    | 2.2               | 22.5  | 2.7     | 5.7       | 1.8     | 2.3      | 3.5     | 2019-01-05 |
| 2019-01-06 | 121.4  | 132.6   | 240.4     | 76.6  | 286.8| ...         | ...  | ...  | ...        | ... | ...         | ...    | ...               | ...   | ...     | ...       | ...     | ...      | ...     | ...        |
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

df = pd.read_csv("dataset_tk.csv")
df.head()

df.columns

df = df.rename(columns={'Unnamed: 0': 'DateTime'})
df['DateTime'] = pd.to_datetime(df['DateTime'],format="%d/%m/%Y %H:%M:%S")
df['Date'] = pd.to_datetime(df['DateTime']).dt.date
df.tail()

"""# Cumulative energy consumption for each state over time"""

subsetdf = df.copy()
subsetdf = subsetdf.drop('DateTime', axis=1)

subsetdf.set_index('Date', inplace=True)

cumsum_df = subsetdf.cumsum(axis=0)
print(cumsum_df)

"""# Transform the cumulative energy consumption data into a daily format"""

states = ['Punjab', 'Haryana', 'Rajasthan', 'Delhi', 'UP',
       'Uttarakhand', 'HP', 'J&K', 'Chandigarh', 'Chhattisgarh', 'Gujarat',
       'MP', 'Maharashtra', 'Goa', 'DNH', 'Andhra Pradesh', 'Telangana',
       'Karnataka', 'Kerala', 'Tamil Nadu', 'Pondy', 'Bihar', 'Jharkhand',
       'Odisha', 'West Bengal', 'Sikkim', 'Arunachal Pradesh', 'Assam',
       'Manipur', 'Meghalaya', 'Mizoram', 'Nagaland', 'Tripura']

count_date = cumsum_df.groupby(cumsum_df.index)[states].sum()

pw_clean = pd.DataFrame(count_date)
pw_clean['Date'] = pd.to_datetime(pw_clean.index)
pw_clean = pw_clean.set_index('Date')

pw_clean.head(20)

plt.figure(figsize=(12, 6))

for state in states:
    pw_clean[state].plot(label=state)

plt.title('Daily Energy Consumption (Selected States)')
plt.xlabel('Date')
plt.ylabel('Energy Consumption')
plt.legend()
plt.grid(True)

# plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

"""# Whats that peak just after 2019-07???

# Let's create a new DataFrame df1 that's a deep copy of the original one, along with additional columns for year, quarter, month, day, week of year, hour, minute, weekday name, and full month name, all extracted from the original 'DateTime' column
"""

df1 = df.copy('Deep')
df1.head()
df1['year'] = df1['DateTime'].apply(lambda x : x.year)
df1['Quarter'] = df1['DateTime'].apply(lambda x : x.quarter)
df1['month'] = df1['DateTime'].apply(lambda x : x.month)
df1['day'] = df1['DateTime'].apply(lambda x : x.day)
df1['weekofyear'] = df1['DateTime'].apply(lambda x : x.weekofyear)
df1['hour'] = df1['DateTime'].apply(lambda x : x.hour)
df1['minute'] = df1['DateTime'].apply(lambda x : x.minute)
df1['weekday'] = df1['DateTime'].apply(lambda x : x.day_name())
df1['MonthName'] = df1['DateTime'].apply(lambda x : x.month_name())
df1.head()

"""# Add a new column named 'timing' to your DataFrame df1, which assigns time periods ("Night", "Morning", etc.) to each hour value"""

def hours2timing(x):
    if x in [22,23,0,1,2,3]:
        timing = 'Night'
    elif x in range(4, 12):
        timing = 'Morning'
    elif x in range(12, 17):
        timing = 'Afternoon'
    elif x in range(17, 22):
        timing = 'Evening'
    else:
        timing = 'X'
    return timing

df1['timing'] = df1['hour'].apply(hours2timing)
df1.head(3)

"""# Separate data by quarter for comparisons"""

Q1 = df1[df1["Quarter"]==1]
Q2 = df1[df1["Quarter"]==2]
Q3 = df1[df1["Quarter"]==3]
Q4 = df1[df1["Quarter"]==4]

#Plot
fig,axes = plt.subplots(2,2,figsize=(17,7),sharex=True,sharey=True)

sns.distplot(Q1["Delhi"],color="skyblue", ax=axes[0,0]).set_title("Q1 - Consumption")
sns.distplot(Q2["Delhi"],color="red", ax=axes[0,1]).set_title("Q2 - Consumption")
sns.distplot(Q3["Delhi"],color="green", ax=axes[1,0]).set_title("Q3 - Consumption")
sns.distplot(Q4["Delhi"],color="gray", ax=axes[1,1]).set_title("Q4 - Consumption")

del Q1, Q2, Q3, Q4

"""# Time series plot of Delhi's energy consumption

## Only for 'Delhi' 'DateTime'
"""

delhi = pd.DataFrame(data=df1,columns=['Delhi','DateTime'])
delhi.head()

"""Set the 'DateTime' column as the index of the delhi df"""

delhi.set_index('DateTime',inplace=True)
delhi.head()

"""# Time series power consumption of delhi"""

delhi.plot(figsize=(14,5),color='Red')
plt.xlabel('Date')
plt.ylabel('Delhi Power Consumption')
plt.show()

"""# Now we can predict for delhi using this delhi dataframe"""

delhi.head()

"""# Things to focus on

columns more dependent on time

columns that simple regression can work upon

Columns that can utilize neural networks

# Time-series analysis with prophet
"""

df1.columns

prophet_df = pd.DataFrame(data=df1,columns=['Delhi','DateTime'])

prophet_df.rename(columns={"DateTime" : "ds", "Delhi" : "y"},inplace=True)
prophet_df.head()

from prophet import Prophet

model = Prophet(seasonality_mode='multiplicative',yearly_seasonality=4)
model.fit(prophet_df)

future = model.make_future_dataframe(periods=12 * 1, freq='MS')
forecast = model.predict(future)
fig = model.plot(forecast)
plt.show()

model.plot_components(forecast)
plt.show()

model = Prophet(seasonality_mode='multiplicative', yearly_seasonality=4, weekly_seasonality=True, daily_seasonality=True)
model.fit(prophet_df)

future = model.make_future_dataframe(periods=12 * 1, freq='MS')
forecast = model.predict(future)

fig = model.plot(forecast)
plt.show()

"""## Black dots: Observed values of our time series
## Blue line: Forecasted values
## Blue shaded regions: Uncertainty intervals of our forecasts

### Our model seems to be going crazy with the data
Need more research

First up our time series values seem too scattered and the model not being able to fit according to it.

The uncertainity region seems way too large too
"""

forecast

forecast.columns

from sklearn.metrics import mean_absolute_error

# forecast = forecast[['ds', 'yhat']].merge(df, on='ds', how='left')

# mean_absolute_error(forecast['y'].dropna(), forecast['yhat'][:len(forecast['y'].dropna())])

# fig2 = model.plot_components(forecast)
# plt.show()

# to suppress a ton of info logs generated by prophet

import logging
logger = logging.getLogger('cmdstanpy')
logger.addHandler(logging.NullHandler())
logger.propagate = False
logger.setLevel(logging.CRITICAL)

"""# Let's try applying prophet for all the states"""

import pandas as pd
import numpy as np
from prophet import Prophet
from sklearn.metrics import mean_absolute_error
import seaborn as sns
import matplotlib.pyplot as plt

def evaluate_prophet_model(state_data, state_name):
    df = state_data[['DateTime', state_name]].rename(columns={"DateTime": "ds", state_name: "y"})

    model = Prophet(seasonality_mode='multiplicative', yearly_seasonality=4, daily_seasonality=True)
    model.fit(df)

    future = model.make_future_dataframe(periods=12 * 1, freq='MS')

    forecast = model.predict(future)

    forecast = forecast[['ds', 'yhat']].merge(df, on='ds', how='left')

    mae = mean_absolute_error(forecast['y'].dropna(), forecast['yhat'][:len(forecast['y'].dropna())])

    return mae


metrics = {'State': [], 'MAE': []}

for state in states:
    mae = evaluate_prophet_model(df1, state)
    metrics['State'].append(state)
    metrics['MAE'].append(mae)

metrics

metrics_df = pd.DataFrame(metrics)

metrics_df.set_index('State', inplace=True)

plt.figure(figsize=(12, 8))
sns.heatmap(metrics_df[['MAE']].sort_values(by=['MAE'], ascending=False), annot=True, cmap='viridis', fmt='.2f')
plt.title('MAE for Each State')
plt.show()

"""### So with the current model UP and Punjab seem to have the worst errors

Let's try changing some seasonalities
"""

statewise_prophet_models = {}

def evaluate_prophet_model(state_data, state_name):
    df = state_data[['DateTime', state_name]].rename(columns={"DateTime": "ds", state_name: "y"})

    model = Prophet(seasonality_mode='multiplicative', yearly_seasonality=True, daily_seasonality=True)
    model.add_seasonality(name='monthly', period=30.5, fourier_order=5) # fourier_order higher captures more complex relationships in the data
    model.fit(df)

    future = model.make_future_dataframe(periods=12 * 1, freq='MS')

    forecast = model.predict(future)

    forecast = forecast[['ds', 'yhat']].merge(df, on='ds', how='left')

    statewise_prophet_models[state_name] = model

    mae = mean_absolute_error(forecast['y'].dropna(), forecast['yhat'][:len(forecast['y'].dropna())])

    return mae


metrics = {'State': [], 'MAE': []}

for state in states:
    mae = evaluate_prophet_model(df1, state)
    metrics['State'].append(state)
    metrics['MAE'].append(mae)

metrics_df = pd.DataFrame(metrics)

metrics_df.set_index('State', inplace=True)

plt.figure(figsize=(12, 8))
sns.heatmap(metrics_df[['MAE']].sort_values(by=['MAE'], ascending=False), annot=True, cmap='viridis', fmt='.2f')
plt.title('MAE for Each State')
plt.show()

"""### Adding monthly sesonality did bring down the errors a notch

Need more research into why the errors are occuring for these few states

Maybe more outliers
"""

!pip install ipywidgets
!jupyter nbextension enable --py widgetsnbextension

"""# How the UI will be

Input: dropdown for states

Input: For year range

Input: For how many months do we want the prediction

Output: Predictions chart of prophet model
"""

import ipywidgets as widgets
from IPython.display import display, clear_output

min_date = df1['DateTime'].min()
max_date = df1['DateTime'].max()

state_dropdown = widgets.Dropdown(
    options=states,
    description='State:',
    disabled=False,
)

date_picker_start = widgets.DatePicker(
    description=f'Start Date ({min_date.date()} - {max_date.date()})',
    disabled=False,
    value=min_date.date()
)

date_picker_end = widgets.DatePicker(
    description=f'End Date ({min_date.date()} - {max_date.date()})',
    disabled=False,
    value=max_date.date()
)

forecast_horizon_slider = widgets.IntSlider(
    value=12,
    min=1,
    max=100,
    step=1,
    description='Months:',
    disabled=False,
)

predict_button = widgets.Button(
    description='Predict',
    disabled=False,
    button_style='',
    tooltip='Click to predict',
    icon='check'
)

output = widgets.Output()


def on_predict_button_clicked(b):
    with output:
        clear_output()
        state = state_dropdown.value
        start_date = pd.to_datetime(date_picker_start.value)
        end_date = pd.to_datetime(date_picker_end.value)
        forecast_horizon = forecast_horizon_slider.value

        state_data = df1[['DateTime', state]].copy()
        state_data['DateTime'] = pd.to_datetime(state_data['DateTime'])
        state_data = state_data[(state_data['DateTime'] >= start_date) & (state_data['DateTime'] <= end_date)]

        if state_data.empty:
            print("No data available for the selected date range. Please select a range within the available data.")
            return

        mae = evaluate_prophet_model(state_data, state)
        model = statewise_prophet_models[state]
        future = model.make_future_dataframe(periods=forecast_horizon, freq='MS')
        forecast = model.predict(future)

        plt.figure(figsize=(12, 8))
        plt.plot(state_data['DateTime'], state_data[state], label='Actual')
        plt.plot(forecast['ds'], forecast['yhat'], label='Predicted')
        plt.fill_between(forecast['ds'], forecast['yhat_lower'], forecast['yhat_upper'], color='gray', alpha=0.2)
        plt.xlabel('Date')
        plt.ylabel('Energy Consumption')
        plt.title(f'Energy Consumption Prediction for {state}')
        plt.legend()
        plt.show()

        print(f'Mean Absolute Error (MAE): {mae:.2f}')

predict_button.on_click(on_predict_button_clicked)

display(widgets.VBox([state_dropdown, date_picker_start, date_picker_end, forecast_horizon_slider, predict_button, output]))

